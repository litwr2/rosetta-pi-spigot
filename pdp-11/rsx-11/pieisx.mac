	.TITLE	PI - Spigot PI calculator using EIS
	.IDENT	/V2.0/
;for macro-11 assembler
;it calculates pi-number using the next C-algorithm
;https://crypto.stanford.edu/pbc/notes/pi/code.html

;#include <stdio.h>
;#define N 2800
;main() {
;   long r[N + 1], i, k, b, c;
;   c = 0;
;   for (i = 1; i <= N; i++)   ;it is the fixed line!, the original was (i = 0; i < N; ...
;      r[i] = 2000;
;   for (k = N; k > 0; k -= 14) {
;      d = 0;
;      i = k;
;      for(;;) {
;         d += r[i]*10000;
;         b = i*2 - 1;
;         r[i] = d%b;
;         d /= b;
;         i--;
;         if (i == 0) break;
;         d *= i;
;      }
;      printf("%.4d", (int)(c + d/10000));
;      c = d%10000;
;   }
;}

;the time of the calculation is quadratic, so if T is time to calculate N digits
;then 4*T is required to calculate 2*N digits
;main loop count is 7*(4+D)*D/16, D - number of digits

;litwr has made this code
;bqt has made RSX-11 version and helped much with optimization
;tricky provided some help
;MMS gave some support
;Thorham and meynaf helped a lot

	.LIBRARY	/LB:[1,1]BQTMAC/

	.MCALL	.IFMT, .FMT, .EOS, .PRINT, .MSG
	.MCALL	QIOW$S, EXIT$S, GTIM$, DIR$
	.MCALL	QIO$, WTSE$, QIOW$

      .radix 10

DIVOF = 1  ;use overflow flag after division, it is faster but can have compatibility issues

.macro div32x16
              ;R4:R2 = R2:R3/R1, R3 = R2:R3%R1
              ;R1 must be odd
;it is not universal division but a particular procedure for pi-spigot
     ;tst r1
     bmi divm           ;for R1 > 0x7fff

.if eq DIVOF
     asl r3
     rol r2

     cmp r2,r1
     bcc div32b

     asr r2
     ror r3
.endc
     div r1,r2   ;r2(hi):r3(lo)/r1 -> r2 - quotient, r3 - remainder
.if ne DIVOF
     bvs div32b
.endc

     clr r4
    .endm div32x16

.macro adiv ?div32n ?l1 ?l1x ?l2
     ;clc          ;check CF = 0!
     ror r1
     mov r2,r4
     asl r4
     inc r4     ;this should be the highest bit of r3
     cmp r4,r1
     bcc div32n

     div r1,r2
     clr r4
     ror r2
     bcc l1

     add r1,r3
l1:  asl r1
     inc r1
     sub r2,r3
     bcc exit

     dec r2
     add r1,r3
     br exit

div32n:
     clr r4
     ror r2
     ror r3
     rol r4   ;save CF
     div r1,r2
     asl r2
     asl r3
     add r4,r3
     cmp r3,r1
     bcs l2

     inc r2
     sub r1,r3
l2:  clr r4
     ror r2
     bcc l1x

     add r1,r3
l1x: asl r1
     inc r1
     sub r2,r3
     bcc exit

     dec r2
     add r1,r3
     br exit
     .endm adiv

.macro bdiv
.if ne DIVOF
     asl r3
     rol r2
.endc
     mov r0,@sp
     mov r3,r0
     mov r2,r3
     clr r2
     div r1,r2
     mov r2,r4
     mov r3,r2
     mov r0,r3
     asr r2
     ror r3
     div r1,r2
     clr r0
     asr r4
     ror r0
     add r0,r2
     adc r4
     mov @sp,r0
     br exit
     .endm bdiv

	.PSECT	DPB,D,RO
TSTART:	GTIM$	T1		; Timer start.
TSTOP:	GTIM$	T2		; Timer stop.

	.PSECT	DATA,D,RW

T1:	.BLKW	8.		; Buffers for time stamps...
T2:	.BLKW	8.

MAXD=8944.			; ??? Max # of digits we allow. ???

MAXS=<<MAXD/2>*7>		; Size of R[] we need to have for that.

ra:	.BLKW	<MAXS>+1
cv:	.WORD	0
kv = kvs + 2

IOSB:	.BLKW	2

BUF:
OBUF:	.BLKB	4

	.PSECT	DPB,D,RO
WRIT:	QIOW$	IO.WAL,TILUN,TIEFN,,IOSB,,<OBUF,4>

	.PSECT	CODE,I,RO

	.ENABL	LSB
START:	.MSG	<"number pi calculator %R (eis-of)">,<R3>

	.IFMT
	.FMT	<"Number of digits (up to %D)? ">,#MAXD
	.EOS
	QIOW$S	#IO.RPR,#TILUN,#TIEFN,,#IOSB,,<#BUF,#8,,R0,R1,#'$>
	TSTB	IOSB
	BPL	10$

	.MSG	<"Error in read: %O">,IOSB
	EXIT$S

10$:	MOV	IOSB+2,R0		; Terminate input with NUL.
	CLRB	BUF(R0)

	MOV	#BUF,R0			; Try to parse input as number.
	CALL	$CDTB
	TST	R2			; Did we stop at NUL?
	BEQ	20$			; Yes.

	.MSG	<"Funny byte in input: %D">,R2
	EXIT$S

20$:	CMP	R1,#MAXD		; Check value against max.
	BLOS	30$

	.MSG	<"Number too large">
	EXIT$S

30$:	MOV	R1,R0			; Round value to even four.
	ADD	#3,R0
	BIC	#3,R0
	CMP	R0,R1			; Did that cause a change?
	BEQ	1$
	.MSG	<"%D digits will be printed">,R0

1$:	
	.MSG	<" ">
	CALL	SPIGOT			; Calculate PI.

;
; Figure out how many ticks passed, and make this
; into 1/100s.
;

;
; First part, find out how many ticks...
;
	MOV	T2+12,R4	; Get ticks.
	SUB	T1+12,R4	; Calculate delta.
	BCC	2$
	ADD	T2+14,R4	; If that was negative, we had wrap. Adjust.
	DEC	T2+10		; And then we have one less second.
2$:
;
; Second part. Convert to 1/100s.
;
	MUL	#100.,R4
	DIV	T2+14,R4	; Result is in R4.

;
; Now get minutes passed.
;
	MOV	T2+8,R1	; Get end minute.
	SUB	T1+8,R1	; Substract start minute.
	BGE	3$		; If result is >= 0 we're good.
	ADD	#60.,R1		; It was less. Adjust minutes.
3$:
;
; Get seconds passed.
;
	MOV	T2+10,R0	; Get end second.
	SUB	T1+10,R0	; Substract start second.
	BGE	4$
	ADD	#60.,R0		; If negative, adjust up.
	DEC	R1		; And one minute less.
;
; Now make seconds...
;
4$:	MUL 	#60.,R1		; Minutes to seconds.
	ADD	R0,R1		; Add in seconds.

	.IFMT
	.FMT	<"%NTime: %D.">,R1

	MOV	R4,R1		; Get 1/100s second value.
	MOV	#<2*2048>+512+10.,R2	; 2 digits, base 10, with leading 0.
	CALL	$CBTA		; Convert.

	.PRINT			; Print string created.

	EXIT$S			; Done.

	.DSABL	LSB
;
; Spigot PI calculation.
;
; In> R0 - Number of digits to calculate.
;
SPIGOT:	 mov r0,r4
         asr r4
         add r0,r4
         asl r0
         add r0,r4    ;r4 <- r0/2*7
         mov r4,@#kv
         tst -(sp)

	DIR$	#TSTART		; Start measure time.
         mov r4,r0     ;fill r-array
         mov #2000,r1
         mov #ra+2,r2
1$:      mov r1,(r2)+
         sob r0,1$

mloop:   clr r5       ;d <- 0
         clr r0

kvs:     mov #0,r1
         asl r1       ;i <- 2k
         br l4x
divm:
         adiv
div32b:
         bdiv

l77:     add r3,r2       ;d <- d/b*i
         adc r4
         sub r2,r5
         sbc r0
         sub r4,r0
         ror r0
         ror r5
l4x:      mov #10000,r2
         mul ra(r1),r2   ;the result in r2 - high, r3 - low
         bpl 202$

         add #10000,r2
202$:    add r3,r5
         mov r5,r3
         adc r2
         add r0,r2   ;sets CF=0
         mov r2,r0
         dec r1          ;b <- 2*i-1, CF=0 for EIS!
         div32x16
exit:
         mov r3,ra+1(r1)      ;r[i] <- d%b
         sob r1,l77        ;i <- i - 1

         mov r2,r3
         mov r4,r2
         div #10000,r2
         add @#cv,r2  ;c + d/10000
         mov r3,@#cv     ;c <- d%10000

	MOV	#OBUF,R5
	    call PR0000
    MOV	#OBUF,R0
	DIR$	#WRIT

         sub #14,@#kv      ;k <- k - 14
         bne mloop

	DIR$	#TSTOP

	TST	(SP)+		; Clean stack.
	RETURN

;
; Output 4 digits
;
; In: R5 - Buffer pointer
;     R2 - Value
;
PR0000:
        mov #1000,r3
	CALL @#PRZ
        mov #100,r3
	CALL @#PRZ
        mov #10,r3
	CALL @#PRZ
	mov r2,r0
PR:	add #48,r0
   	movb r0,(r5)+
        return

PRZ:	mov #65535,r0
4$:	inc r0
	cmp r2,r3
	bcs PR

	sub r3,r2
	br 4$

	.END	START
