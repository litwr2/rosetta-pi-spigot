;for macro-11 assembler
;it calculates pi-number using the next C-algorithm
;https://crypto.stanford.edu/pbc/notes/pi/code.html

;#include <stdio.h>
;#define N 2800
;main() {
;   long r[N + 1], i, k, b, c;
;   c = 0;
;   for (i = 1; i <= N; i++)   ;it is the fixed line!, the original was (i = 0; i < N; ...
;      r[i] = 2000;
;   for (k = N; k > 0; k -= 14) {
;      d = 0;
;      i = k;
;      for(;;) {
;         d += r[i]*10000;
;         b = i*2 - 1;
;         r[i] = d%b;
;         d /= b;
;         i--;
;         if (i == 0) break;
;         d *= i;
;      }
;      printf("%.4d", (int)(c + d/10000));
;      c = d%10000;
;   }
;}

;the time of the calculation is quadratic, so if T is time to calculate N digits
;then 4*T is required to calculate 2*N digits
;main loop count is 7*(4+D)*D/16, D - number of digits

;litwr has made this code
;bqt has made RSX-11 version and helped much with optimization and this text
;tricky provided some help
;MMS gave some support
;Thorham and meynaf helped a lot

;there is a neater and nicer pi-spigot implementation for RSX-11 (EIS only)
;it can be found at ftp://guest:guest@Mim.Update.UU.SE/US:[BQT]PIRSX.MAC
;it is even faster but rather only theoretically and in an invisible amount
;however its maximum for digits produced is less and it uses its own buffer
;to keep all the output which is forbidden by rule #4

  .TITLE  PI - Spigot PI calculator using EIS

  .MCALL  QIOW$S, EXIT$S, GTIM$, DIR$
  .MCALL  QIOW$, WTSE$, QIO$

      .radix 10

IO = 1
MEMSZ = 31864       ;this is a constant calculated from data in a MAP-file
                    ;produced by a linker, 10500 is enough for 3000 digits

DIVOF = 1  ;use overflow flag after division, it is faster but can have
           ; compatibility issues with some PDP-11, for example, 11/34 and 11/44

.macro div32x16
              ;R4:R2 = R2:R3/R1, R3 = R2:R3%R1
              ;R1 must be odd
;it is not universal division but a particular procedure for pi-spigot
     ;tst r1
     bmi divm           ;for R1 > 0x7fff

.if eq DIVOF
     asl r3
     rol r2

     cmp r2,r1
     bcc div32b

     asr r2
     ror r3
.endc
     div r1,r2   ;r2(hi):r3(lo)/r1 -> r2 - quotient, r3 - remainder
.if ne DIVOF
     bvs div32b
.endc

     clr r4
    .endm div32x16

.macro adiv ?div32n ?l1 ?l1x ?l2
     ;clc          ;check CF = 0!
     ror r1
     mov r2,r4
     asl r4
     inc r4     ;this should be the highest bit of r3
     cmp r4,r1
     bcc div32n

     div r1,r2
     clr r4
     ror r2
     bcc l1

     add r1,r3
l1:  asl r1
     inc r1
     sub r2,r3
     bcc exit

     dec r2
     add r1,r3
     br exit

div32n:
     clr r4
     ror r2
     ror r3
     rol r4   ;save CF
     div r1,r2
     asl r2
     asl r3
     add r4,r3
     cmp r3,r1
     bcs l2

     inc r2
     sub r1,r3
l2:  clr r4
     ror r2
     bcc l1x

     add r1,r3
l1x: asl r1
     inc r1
     sub r2,r3
     bcc exit

     dec r2
     add r1,r3
     br exit
     .endm adiv

.macro bdiv
.if ne DIVOF
     asl r3
     rol r2
.endc
     mov r5,@sp
     mov r2,r5
     clr r4
     div r1,r4
     mov r5,r2
     asr r2
     ror r3
     div r1,r2
     clr r5
     asr r4
     ror r5
     add r5,r2
     adc r4
     mov @sp,r5
     br exit
     .endm bdiv

  .PSECT  CODE,I,RW
START:
    mov #msg1m,r5
    mov #MAXD,r2
    call PR0000
    QIOW$S  #IO.WLB, #5, #5,,,,<#msg1, #msg1m-msg1, #'$>
    MOV  #msg1m,R0
  MOV  #7,R1
  QIOW$S  #IO.RPR,#5,#5,,#IOSB,,<#OBUF,#8,,R0,R1>
  TSTB  IOSB
  BPL  10$

    QIOW$S  #IO.WLB, #5, #5,,,,<#msg2, #msg3-msg2, #40>
  EXIT$S

10$:  MOV  IOSB+2,R0    ; Terminate input with NUL.
  CLRB  OBUF(R0)

  MOV  #OBUF,R0      ; Try to parse input as number.
  CALL  $CDTB
  TST  R2      ; Did we stop at NUL?
  BEQ  20$      ; Yes.

  QIOW$S  #IO.WLB, #5, #5,,,,<#msg3, #msg4-msg3, #40>
  EXIT$S

20$:  CMP  R1,#MAXD    ; Check value against max.
  BLOS  30$

  QIOW$S  #IO.WLB, #5, #5,,,,<#msg4, #msg5-msg4, #40>
  EXIT$S

30$:
  MOV  R1,R0      ; Round value to even four.
  ADD  #3,R0
  BIC  #3,R0
  CMP  R0,R1      ; Did that cause a change?
  BEQ  31$

    mov r0,r2
    mov r0,-(sp)
    mov #msg5,r5
    call PR0000
    QIOW$S  #IO.WLB, #5, #5,,,,<#msg5, #msg6-msg5, #40>
    mov (sp)+,r0

31$:
    QIOW$S  #IO.WLB, #5, #5,,,,<#msg5, #1, #40>
         mov r0,r4
         asr r4
         add r0,r4
         asl r0
         add r0,r4    ;r4 <- r0/2*7
         mov r4,@#kv
         tst -(sp)

       DIR$ #TSTART    ; Start measure time.
         mov r4,r0     ;fill r-array
         mov #2000,r1
         mov #ra+2,r2
1$:      mov r1,(r2)+
         sob r0,1$

mloop:   clr r5       ;d <- 0
         clr r0
kvs:     mov #0,r1
         asl r1       ;i <- 2k
         br l4x
divm:
         adiv
div32b:
         bdiv

l77:     add r3,r2       ;d <- d/b*i
         adc r4
         sub r2,r5
         sbc r0
         sub r4,r0
         ror r0
         ror r5
l4x:     mov #10000,r2
         mul ra(r1),r2   ;the result in r2 - high, r3 - low
         bpl 202$

         add #10000,r2
202$:    add r3,r5
         mov r5,r3
         adc r2
         add r0,r2   ;sets CF=0
         mov r2,r0
         dec r1          ;b <- 2*i-1, CF=0 for EIS!
         div32x16
exit:
         mov r3,ra+1(r1)      ;r[i] <- d%b
         sob r1,l77        ;i <- i - 1

.if ne IO
         mov r2,r3
         mov r4,r2
         div #10000,r2
         add @#cv,r2  ;c + d/10000
         mov r3,@#cv     ;c <- d%10000

       MOV #OBUF,R5
         DIR$ #WAIT
       call PR0000
       DIR$ #WRIT
.endc
         sub #14,@#kv      ;k <- k - 14
         bne mloop

         DIR$ #WAIT
       DIR$ #TSTOP
         tst (sp)+
;
; Figure out how many ticks passed, and make this
; into 1/100s.
;

;
; First part, find out how many ticks...
;
  MOV  T2+12,R4  ; Get ticks.
  SUB  T1+12,R4  ; Calculate delta.
  BCC  2$

  ADD  T2+14,R4  ; If that was negative, we had wrap. Adjust.
  DEC  T2+10    ; And then we have one less second.
2$:
;
; Second part. Convert to 1/100s.
;
    MOV R4,R0
    MOV #100,R1
    call $MUL    ;R0/R1 = R0:R1
    mov r1,r2
    mov r0,r1
    mov T2+14,r0
    call $DDIV   ;R1:R2/R0 = R1:R2 mod R0
    mov r2,r4
;
; Now get minutes passed.
;
  MOV  T2+8,R1  ; Get end minute.
  SUB  T1+8,R1  ; Substract start minute.
  BGE  3$    ; If result is >= 0 we're good.

  ADD  #60,R1    ; It was less. Adjust minutes.
3$:
;
; Get seconds passed.
;
  MOV  T2+10,R0  ; Get end second.
  SUB  T1+10,R0  ; Substract start second.
  BGE  4$

  ADD  #60,R0    ; If negative, adjust up.
  DEC  R1    ; And one minute less.
;
; Now make seconds...
;
4$:  mov r0,-(sp)
    mov #60,r0
    call $mul           ;Minutes to seconds
  ADD  (sp)+,R1    ;Add in seconds
    mov #ra,r0
    MOVB #32,(r0)+      ;a white space
    MOV #<5*2048>+10,R2  ;5 places, base 10
    CALL  $CBTA
    movb #'.,(r0)+
    MOV  R4,R1
  MOV #<2*2048>+512+10,R2  ;2 digits, base 10, with leading 0
  CALL  $CBTA
    sub #ra,r0
    QIOW$S  #IO.WLB,#5, #5,,,,<#ra, r0>
  EXIT$S

;
; Output 4 digits
;
; In: R5 - Buffer pointer
;     R2 - Value
;
PR0000:
    mov #1000,r3
  CALL @#PRZ
    mov #100,r3
  CALL @#PRZ
    mov #10,r3
  CALL @#PRZ
  mov r2,r0
PR:  add #48,r0
     movb r0,(r5)+
    return

PRZ:  mov #65535,r0
4$:  inc r0
  cmp r2,r3
  bcs PR

  sub r3,r2
  br 4$

T1:  .BLKW  8    ;Buffers for time stamps
T2:  .BLKW  8

MAXD=<<MEMSZ/7>/4>*8      ;Max # of digits we allow

cv:  .WORD  0
kv = kvs + 2

IOSB:  .BLKW  2
OBUF:  .BLKB  8

TSTART:  GTIM$  T1    ;Timer start.
TSTOP:  GTIM$  T2    ;Timer stop.
EVNTFLG = 5
WRIT:  QIO$  IO.WAL,5,EVNTFLG,,,,<OBUF,4>
WAIT:  WTSE$  EVNTFLG

ra:
msg1:  .ascii "number pi calculator v2 (EIS"
.if ne DIVOF
       .ascii "-of"
.endc
       .ascii ")"<10><13>
       .ascii "number of digits (up to "
msg1m: .ascii "0000)? "
msg2:  .ascii "Error in read"
msg3:  .ascii "Non-digit character in input"
msg4:  .ascii "Number too large"
msg5:  .ascii "0000 digits will be printed"
msg6:
memfill: .blkb MEMSZ
       .blkb MEMSZ
eom:
  .END  START
